## JS 单线程
我们知道 `JavaScript` 是单线程的，所谓单线程，是指在 `JavaScript引擎` 中负责解释和执行 `JavaScript` 代码的线程唯一，同一时间上只能执行一件任务。
为什么是单线程的喃？这是因为 `JavaScript` 可以修改 `DOM结构`，如果 `JavaScript引擎线程` 不是单线程的，那么可以同时执行多段 `JavaScript`，如果这多段 `JavaScript` 都修改 `DOM`，那么就会出现 `DOM冲突`。
为了避免 `DOM` 渲染的冲突，可以采用**单线程或者死锁**，`JavaScript` 采用了单线程方案。

---

### JS 内存机制
`JavaScript` 中的内存空间主要分为三种类型：
* 代码空间：主要用来存放可执行代码
* 栈空间：调用栈的存储空间就是栈空间。
* 堆空间

`JavaScript` 中的变量类型有 8 种，可分为两种：`基本类型`、`引用类型`
基本类型：
* undefined
* null
* number
* string
* boolean
* symbol
* bigint

引用类型：
* object

**基本类型是保存在栈内存中的简单数据段，而引用类型保存在堆内存中。**

#### 栈空间
基本类型在内存中占有**固定大小**的空间，所以它们的值保存在栈空间，我们通过**按值访问**。

#### 堆空间
引用类型，**值大小不固定**，但指向值的**指针大小（内存地址）是固定的**，所以**把对象放入堆中，将对象的地址放入栈中**，这样，在调用栈中切换上下文时，只需要将指针下移到上个执行上下文的地址就可以了，同时保证了栈空间不会很大。
当查询引用类型的变量时，先从栈中读取内存地址，然后再通过地址找到堆中的值。对于这种，我们把它叫做**按引用访问**。

---

### 垃圾回收
#### 回收栈空间
在 `JavaScript` 执行代码时，主线程上会存在 `ESP指针`，用来指向调用栈中当前正在执行的上下文，例如当前正在执行 foo 函数：当 foo 函数执行完成后，ESP 向下指向全局执行上下文，此时需要销毁 foo 函数。

怎么销毁？
当 `ESP指针` 指向全局执行上下文，foo 函数执行上下文已经是无效的了，当有新的执行上下文进来时，可以直接覆盖这块内存空间。

即：`JavaScript引擎` 通过向下移动 `ESP指针` 来销毁存放在栈空间中的执行上下文。

#### 回收堆空间
`标记-清除法`
`V8` 中把堆分成**新生代**与**老生代**两个区域：
* 新生代：用来存放生存周期较短的小对象，一般只支持1～8M的容量
* 老生代：用来存放生存周期较长的对象或大对象

`V8` 对这两块使用了不同的回收器：
* 新生代使用**副垃圾回收器**
* 老生代使用**主垃圾回收器**

都采用了同样的流程（三步走）：
* `标记`：标记堆空间中的活动对象（正在使用）与非活动对象（可回收）
* `垃圾清理`：回收非活动对象所占用的内存空间
* `内存整理`：当进行频繁的垃圾回收时，内存中可能存在大量不连续的内存碎片，当需要分配一个需要占用较大连续内存空间的对象时，可能存在内存不足的现象，所以，这时就需要整理这些内存碎片。

##### 副垃圾回收器
副垃圾回收器与主垃圾回收器虽然都采用同样的流程，但使用的回收策略与算法是不同的。
它采用 `Scavenge算法` 及 `对象晋升策略` 来进行垃圾回收。
Scavenge 算法
* 把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
* 新加入的对象都加入对象区域，当对象区满的时候，就执行一次垃圾回收，执行流程如下：
  * `标记`：首先要对区域内的对象进行标记（活动对象、非活动对象）
  * `垃圾清理`：然后进行垃圾清理：将对象区的活动对象复制到空闲区域，并进行有序的排列，当复制完成后，对象区域与空闲区域进行翻转，空闲区域晋升为对象区域，对象区域为空闲区域
  * 翻转后，对象区域是没有碎片的，此时不需要进行内存整理

但新生代区域很小的，一般1～8M的容量，所以它很容易满，所以 `JavaScript引擎` 采用**对象晋升策略**来处理，即只要对象经过两次垃圾回收之后依然继续存活，就会被晋升到老生代区域中。

##### 主垃圾回收器
老生代区域里除了存在从新生代晋升来的存活时间久的对象，当遇到大对象时，**大对象也会直接分配到老生代**。
* `标记`：遍历调用栈，看老生代区域堆中的对象是否被引用，被引用的对象标记为活动对象，没有被引用的对象（待清理）标记为垃圾数据。
* `垃圾清理`：将所有垃圾数据清理掉
* `内存整理`：标记-整理策略，将活动对象整理到一起。

##### 增量标记
`V8` 浏览器会自动执行垃圾回收，但由于也是运行在主线程上的，一旦执行垃圾回收，就要打断 `JavaScript` 的运行，可能会或多或少的造成页面的卡顿，影响用户体验，所以 `V8` 决定采用**增量标记算法**回收：
即把垃圾回收拆成一个个小任务，穿插在 `JavaScript` 中执行。

---
### JS 函数调用栈
在 `JavaScript` 中有很多函数，经常会出现一个函数调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种栈结构 。
调用栈是 `JavaScript` 用来管理**函数执行上下文**的一种数据结构，**它记录了当前函数执行的位置，哪个函数正在被执行**。 如果我们执行一个函数，就会为函数创建执行上下文并放入栈顶。 如果我们从函数返回，就将它的执行上下文从栈顶弹出。
函数调用栈是有大小的，当入栈过多，就会发生**栈溢出**。

浏览器中获取调用栈的方式：
* `断点调试`
* `console.trace()`


---