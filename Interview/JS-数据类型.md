JavaScript 数据类型

详见MDN-数据类型

分为两大类：基本类型 和 Object。
除了Object（以下简称“对象”），其余都是基本类型，包括比较新的 Symbol 和 BigInt。
基本类型包括：Number、String、Boolean、Undefined、Null、Symbol、BigInt。

这样划分，肯定是有依据的，即两者存储方式不一样。
这里提到的存储方式，其他语言也都一样会有：最常用的就是栈和堆，js主要是这两种。当然像 C++ 一些比较复杂的语言，还有其他划分（待深入确认）

其实不管什么语言，什么数据类型，数据都是需要分配内存空间的，单位为 bit，表示1或0。
像 C++ 这类语言，会给变量制定类型，例如 int、double 等。在变量声明时，就会根据类型分配相应大小的内存空间，int 是32位，double 是64位。而 js 不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。

前面说到的 基本类型，都是直接存储在栈中。例如 var a = 1，就会在栈中新建一块内存空间，存放值1。

而 对象 的存储，会使用到栈和堆。例如 var a = {}，会在栈中存储一个变量a，a存储的不是对象的数据内容，而是一个计算机地址，也叫指针，指向堆的某个位置。而这个位置存放的数据才是对象的数据内容。
下面是我的理解：这里的指针根据电脑的不同，例如现在基本都是64位电脑，那指针的长度就是64位。也即可能a存的值是01010101010101010101010101010....64个。也可能不是根据电脑，而是根据 js 自己的设定，总之指针的位数是固定的。

这是两种数据类型的区别，从这点区别可以引申出很多东西。


一、原始值不可变 - 参考链接

string跟数组有点类似，可以直接通过下标获取对应位置的字符，但是不能像数组一样更改值。
而像 a += 'world'，这种操作，也不是在原来的字符串上直接更改，而是另外创建了一个字符串，再用这个新的赋值给a， 原始字符串并没有被改变。

二、临时包装对象 - 参考链接
对于基本类型的数据，还有一点比较隐晦的，叫临时包装对象。

例如这里 a 是string类型，为什么可以像对象一样去访问 length 这个属性呢？
因为 js 设计时，为了方便number、string、boolean等基本类型的使用，底层加的一些操作。
在基本类型变量访问属性时，会将其包装成对应的对象。
也只会在访问属性的时候会做这个包装，所以一般开发没什么感觉，调用完属性后，它又会变回原来的简单的基本值。例如你给a的ahahaha属性赋值，结束后a会变回基本值，也就没有ahahaha这个属性，这也算是基本类型值不可变的一个理解。

三、*** 类型的判断 - 参考链接
判断类型的方式主要有是三种：typeof、instanceof、Object.prototype.toString
A. *** typeof
首先先看 typeof 运算符有哪些返回值：number、string、boolean、undefined、symbol、bigint、object、function。注意格式是小写的字符串
*** 基本类型的 typeof
可以看到，number、string、boolean、undefined、symbol、bigint 对应前面提到的几种基本类型，但有个例外是 null。

js 设计缺陷
这是 js 设计的一个缺陷，跟很多语言一样，这些缺陷有些是设计者的偏好，有些则是设计时的 bug。而 js 是一门不断自我更新成长的语言，它应对这些缺陷的方式，是添加新的 feature 来弥补。至于缺陷为什么不修复，因为 js 发布一个版本后，会被广泛用于开发各种Web应用，如果把这个缺陷修复，那很多应用将会出现问题，故处理缺陷的方式是添加新的 feature 来弥补。举个例子，函数 isNaN


isNaN 的作用，是用来判断一个值是不是非数值型（像这种 isxxx 格式的函数，就是做某种判断，返回布尔值 true/false。以后开发自己写函数名也要依照这种规范，以增加代码可读性）。
而 isNaN 的初衷是为了判断一个值是不是 NaN，但从上面的用法看出，如果值是字符串’a’也会返回true，所以这个函数是有缺陷的。
NaN(Not-A-Number) ，表示非数值，需要注意 NaN 的类型是 number。
NaN 还有很神奇的一点是：NaN 不等于 NaN。至于为什么是这样，也跟 js number 的实现有关，NaN 表示的值不是一个确定的数，而是一个范围。


且 js 中 number 类型的还有很多类似 NaN 的特殊值，例如 Infinity，表示无穷大。


因为以上原因，想要判断一个变量是不是 NaN，需要这么写

if ( typeof a === ‘number’ && isNaN(a) )

后面 js 更新了新的 feature，来弥补这个问题，即函数 Number.isNaN
注意跟上面的 isNaN 是完全不同的两个函数，这个函数真正实现了判断一个值是不是 NaN。
*** 对象的 typeof
讲完了缺陷的存在，回去 typeof 的用法。可以看到还有另外两个返回值：object、function。
对于对象，通过 typeof 运算符基本都会返回 object，例如数组、正则等。


但有一个例外，就是函数，它的返回值是 function。但函数并不是一个类型，它也是属于对象的一种，这个是特例。

总结
typeof 的用法需要分基本类型和对象：
除了 null 返回 'object'，其他基本类型返回值都是本身；
除了函数返回 ‘function’，其他对象返回 ‘object’。
B. *** instanceof
通过对 typeof 的了解，可以发现，typeof 无法准确判断一个对象的类型。
所以 instanceof 登场，例如前面 数组 和 正则 对象的判断：


*** instanceof 的语法

object instanceof constructor

其中 object 表示待测的实例对象，construcor 表示构造函数。前面的 Array、RegExp 其实就是构造函数。
需要注意：instanceof 不能用于判断基本类型，只能用于判断对象。


*** 构造函数
构造函数：首字母大写的函数，当然首字母大写只是一种规范，为了和普通函数做区分。其实任意一个函数都可以作为构造函数，只是普通函数不这么使用。
构造函数使用的方式：new constructor()，返回改构造函数的一个实例对象。例如

var a = new Object()

这里变量 a，就是通过 Object 构造函数，实例化得到的对象。
这里可能你会问，那 var a = {}，跟上面有什么区别，其实没多大区别。这种用法是我们平常用来创建对象变量的，它本质走的是上面那种构造函数的方式，js 底层帮我们做了简化，称作“字面量”。js 这些便捷的设计统称做“语法糖”，待你们自己去发现其他的。
包括 var a = new Array() 与 var a = []，同样区别不大。建议使用 字面量 的格式。

拓展阅读 - 字面量与构造函数

C. typeof 和 instanceof 的原理 - 参考链接
instanceof 的原理与原型链有关，之后另外写个关于原型的文档。

D. *** Object.prototype.toString
虽然 instanceof 可以用于判断对象的类型，但不能得到一个对象的具体类型。
而 Object.prototype.toString 基本是万能的。


经过处理封装的函数，可以直接获得变量的类型，大写开头的字符串

function getType(obj) {
  return Object.prototype.toString.call(obj).replace(/\[object\s|\]/g, '');
}


拓展知识
Number 类型的底层实现 - 双精度IEEE 754 64位浮点类型
Javascript 标准内置对象




待调研：
C++等复杂语言，存储方式有哪些
string类型变量的存储
undefined 从 null 的实现



