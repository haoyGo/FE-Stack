## 优化方案
`vue3` 从很多层面都做了优化，可以分成三个方面：
* 源码
* 性能
* 语法 API

### 源码
源码可以从两个层面展开：
* 源码管理
* `TypeScript`

`vue3` 整个源码是通过 `monorepo` 的方式维护的，根据功能将不同的模块拆分到 `packages` 目录下面不同的子目录中

这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性.

另外一些 `package`（比如 `reactivity` 响应式库）是可以独立于 `Vue` 使用的，这样用户如果只想使用 `Vue3` 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 `Vue`

### 性能
`vue3` 是从什么哪些方面对性能进行进一步优化呢？

#### 体积优化
* `webpack tree-shaking`

#### 编译优化
* 重写了 `Vdom diff` 实现
* 编译模版优化
* 更高效组件初始化
* `update` 性能提高
* `SSR` 速度提高

#### 数据劫持优化
在 `vue2` 中，数据劫持是通过 `Object.defineProperty`，这个 API 有一些缺陷，并不能检测对象属性的添加和删除.
相比之下，`vue3` 是通过 `proxy` 监听整个对象，那么对于删除还是监听当然也能监听到。
同时 `Proxy` 并不能监听到内部深层次的对象变化，而 `Vue3` 的处理方式是在 `getter` 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归。

### 语法 API
composition API，其两大显著的优化：
* 优化逻辑组织
* 优化逻辑复用
