# 微前端

## 1. 微前端概述

### 1.1 定义
微前端是一种将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块的架构风格。这些小块可以独立运行、独立开发、独立部署，同时又可以组合成一个大型的单体应用。

### 1.2 解决的问题
1. 巨型应用的拆分和治理
2. 遗留系统的渐进式改造
3. 团队自治和技术栈灵活性
4. 独立开发、独立部署

## 2. 主流实现方案

### 2.1 Single-SPA
- 最早的微前端框架之一
- **提供了基础的路由劫持和应用加载**
- 需要手动处理 JS 隔离、CSS 隔离等问题


### 2.2 qiankun
- 阿里巴巴开源的微前端框架
- 基于 Single-SPA 封装
- **提供了完整的 JS 沙箱、CSS 隔离方案**
- 提供了预加载、应用通信等高级特性

**技术特点：**
```javascript
// 主应用
import { registerMicroApps, start, initGlobalState } from 'qiankun';

// 初始化全局状态
const { onGlobalStateChange, setGlobalState } = initGlobalState({
  user: 'qiankun',
});

// 监听全局状态变更
onGlobalStateChange((value, prev) => console.log('[主应用]', value, prev));

// 注册子应用
registerMicroApps([
  {
    name: 'vue-app',
    entry: '//localhost:8080',
    container: '#container',
    activeRule: '/vue',
    props: {
      shared: sharedLib,
      getGlobalState: () => globalState
    }
  },
  {
    name: 'react-app',
    entry: '//localhost:3000',
    container: '#container',
    activeRule: '/react'
  }
]);

// 启动应用
start({
  prefetch: true,
  sandbox: {
    strictStyleIsolation: true,
    experimentalStyleIsolation: true
  }
});

// 子应用 - 生命周期
export async function bootstrap() {
  console.log('[vue] vue app bootstraped');
}

export async function mount(props) {
  const { container, shared, getGlobalState } = props;
  render(props);
}

export async function unmount() {
  instance.$destroy();
  instance.$el.innerHTML = '';
  instance = null;
}
```

### 2.3 Micro-App
- 京东开源的微前端框架
- **基于 Web Components 实现**
- **实现了真正的 DOM 隔离**
- 简单易用，接入成本低

**技术特点：**
```html
<!-- 主应用使用 -->
<micro-app 
  name="app1"
  url="http://localhost:3000/"
  baseroute="/app1">
</micro-app>
```

### 2.4 Module Federation
- Webpack 5 原生支持的微前端方案
- 实现了真正的模块共享
- 支持运行时动态加载

**技术特点：**
```javascript
// webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        app1: 'app1@http://localhost:3001/remoteEntry.js'
      },
      shared: ['react']
    })
  ]
};
```

### 2.5 IceStark
- 阿里飞冰团队开发的微前端框架
- 提供了完整的微前端解决方案
- 支持多种框架接入

**技术特点：**
```javascript
// 主应用配置
import { AppRouter, AppRoute } from '@ice/stark';

<AppRouter>
  <AppRoute
    path="/seller"
    url={[
      '//localhost:3000/js/index.js',
      '//localhost:3000/css/index.css'
    ]}
  />
</AppRouter>
```

### 2.6 框架对比
| 框架 | 实现原理 | 优势 | 劣势 | 适用场景 |
|------|----------|------|------|----------|
| Single-SPA | 路由劫持 | 灵活性高 | 需要手动处理隔离 | 技术栈一致的项目 |
| qiankun | Single-SPA + 沙箱 | 完整的隔离方案 | 打包体积较大 | 大型企业级应用 |
| Micro-App | Web Components | DOM级别隔离 | 兼容性要求高 | 需要强隔离的项目 |
| Module Federation | Webpack原生模块联邦 | 共享依赖 | 依赖Webpack5 | 模块共享需求强的项目 |
| IceStark | 路由分发 | 开箱即用 | 耦合度较高 | 快速落地的中小型项目 |

## 3. 核心技术实现

### 3.1 JS 隔离
1. **快照沙箱**
```javascript
class SnapshotSandbox {
  constructor() {
    this.windowSnapshot = {};
    this.modifyPropsMap = {};
  }

  active() {
    // 记录当前 window 对象的状态
    for (const prop in window) {
      this.windowSnapshot[prop] = window[prop];
    }
    // 恢复之前的修改
    Object.keys(this.modifyPropsMap).forEach(prop => {
      window[prop] = this.modifyPropsMap[prop];
    });
  }

  inactive() {
    for (const prop in window) {
      if (window[prop] !== this.windowSnapshot[prop]) {
        // 记录变更
        this.modifyPropsMap[prop] = window[prop];
        // 还原window
        window[prop] = this.windowSnapshot[prop];
      }
    }
  }
}
```

2. **Proxy 沙箱**
```javascript
class ProxySandbox {
  constructor() {
    const rawWindow = window;
    const fakeWindow = {};
    const proxy = new Proxy(fakeWindow, {
      get(target, prop) {
        return prop in target ? target[prop] : rawWindow[prop];
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      }
    });
    this.proxy = proxy;
  }
}
```

### 3.2 CSS 隔离
1. **Dynamic Stylesheet**
- 动态切换样式表
- 每个子应用加载时添加样式，卸载时移除

2. **CSS Modules**
- 打包时生成唯一的类名
- 实现了编译时的 CSS 隔离

3. **Shadow DOM**
- 提供了完整的 DOM 隔离
- CSS 样式天然隔离

### 3.3 应用通信与状态管理

1. **基于 Props 通信**
```javascript
// 主应用
registerMicroApp({
  name: 'app1',
  entry: '//localhost:8080',
  container: '#container',
  props: {
    data: store.data,
    methods: {
      onEvent: (data) => {
        console.log('子应用事件:', data);
        // 处理子应用事件
      }
    }
  }
});

// 子应用
export async function mount(props) {
  const { data, methods } = props;
  // 使用主应用传递的数据
  console.log('主应用数据:', data);
  // 调用主应用方法
  methods.onEvent({ type: 'click', data: 'some data' });
}
```

2. **发布订阅模式**
```javascript
// 实现全局事件总线
class EventBus {
  constructor() {
    this.events = {};
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }

  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}

// 主应用
window.eventBus = new EventBus();
window.eventBus.on('app1-event', data => {
  console.log('收到子应用消息:', data);
});

// 子应用
window.eventBus.emit('app1-event', { type: 'update', data: 'new data' });
```

3. **全局状态管理**
```javascript
// 使用Redux实现全局状态
import { createStore } from 'redux';

// 主应用
const store = createStore(reducer);

registerMicroApp({
  name: 'app1',
  props: {
    store: {
      getState: store.getState,
      dispatch: store.dispatch,
      subscribe: store.subscribe
    }
  }
});

// 子应用
export async function mount(props) {
  const { store } = props;
  
  // 订阅状态变化
  store.subscribe(() => {
    const state = store.getState();
    console.log('全局状态更新:', state);
  });

  // 修改状态
  store.dispatch({
    type: 'UPDATE_DATA',
    payload: { /* ... */ }
  });
}
```

4. **自定义通信方案**
```javascript
// 主应用
class AppCommunication {
  constructor() {
    this.apps = new Map();
    this.globalState = {};
  }

  // 注册子应用
  registerApp(appName, context) {
    this.apps.set(appName, context);
  }

  // 设置全局状态
  setGlobalState(state) {
    this.globalState = { ...this.globalState, ...state };
    // 通知所有子应用
    this.apps.forEach(context => {
      context.onGlobalStateChange(this.globalState);
    });
  }

  // 获取指定子应用上下文
  getAppContext(appName) {
    return this.apps.get(appName);
  }
}

const communication = new AppCommunication();

// 子应用使用
communication.registerApp('app1', {
  onGlobalStateChange: (state) => {
    console.log('全局状态变化:', state);
  }
});
```

## 4. 最佳实践

### 4.1 性能优化

1. **预加载策略**
```javascript
// qiankun预加载配置
start({
  prefetch: 'all', // 预加载所有子应用
  sandbox: {
    strictStyleIsolation: true
  }
});

// 自定义预加载
const preloadApp = async (entry) => {
  const res = await fetch(entry);
  const html = await res.text();
  // 预加载资源
  const assets = parseHTML(html);
  assets.forEach(asset => loadAsset(asset));
};
```

2. **资源加载优化**
- 使用HTTP2多路复用
- 配置合适的缓存策略
- 实现资源并行加载
- CDN分发加速

3. **公共依赖共享**
```javascript
// Webpack配置
module.exports = {
  externals: {
    react: 'React',
    'react-dom': 'ReactDOM'
  },
  shared: {
    react: {
      singleton: true,
      requiredVersion: '^17.0.0'
    }
  }
};
```

4. **按需加载优化**
```javascript
// 路由级别的按需加载
const routes = [
  {
    path: '/app1',
    component: () => import('./apps/app1'),
    loading: LoadingComponent
  }
];

// 子应用按需加载
const loadApp = async (name) => {
  const app = await System.import(name);
  return app.default;
};
```