## Vue2 响应式原理
**Vue 的双向绑定基于数据劫持+观察者模式实现。**

* `data` 对象内部使用 `Object.defineProperty` 递归地将属性进行劫持（只会劫持已经存在的属性）。基于观察者模式，每一个被劫持的属性都有一个目标池，用来存放收集到的 `watcher`，就是观察者，然后设置属性的 `get` 和 `set`。
* 当模板编译到例如 `v-model` 或者小胡子语法的时候，就会触发 `get`，这个时候会将 `watcher` 收集到每一个属性的目标池中。这个过程就是 **`依赖收集`**
* 当修改数据的时候，例如输入框中进行输入，或者直接修改数据，就会触发 `set`，这个时候会将目标池中的所有 `watcher` 的 `update` 方法调用，更新DOM，这个过程就是 **`派发更新`**

参照样例 [手写简易MVVM](./手写简易MVVM/index.js)


`Watcher` 订阅者：观察属性提供回调函数以及收集依赖（如计算属性 `computed`，`vue` 会把该属性所依赖数据的 `dep` 添加到自身的 `deps` 中），当被观察的值发生变化时，会接收到来自 `dep` 的通知，从而触发回调函数。
`Watcher` 类的实现比较复杂，因为他的实例分为渲染 watcher（`render-watcher`）、计算属性 watcher（`computed-watcher`）、侦听器 watcher（`normal-watcher`）三种。
* `computed-watcher`：我们在组件钩子函数 `computed` 中定义，这类 `watcher` 有个特点：当计算属性依赖于其他数据时，属性并不会立即重新计算，**只有之后其他地方需要读取属性的时候，它才会真正计算**，即具备 `lazy`（懒计算）特性。
* `normal-watcher`：我们在组件钩子函数 `watch` 中定义，即只要监听的属性改变了，都会触发定义好的回调函数。
* `render-watcher`：每一个组件都会有一个 `render-watcher`，当 `data/computed` 中的属性改变的时候，会调用该 `render-watcher` 来更新组件的视图。

这三种 `watcher` 也有固定的执行顺序，分别是：`computed-render -> normal-watcher -> render-watcher`。尽可能的保证，在更新组件视图的时候，`computed` 属性已经是最新值了，如果 `render-watcher` 排在 `computed-render` 前面，就会导致页面更新的时候 `computed` 值为旧数据。